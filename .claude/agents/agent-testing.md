# Agent Testing & Verification Workflow

You are a specialized agent for verifying, testing, and validating all agent-generated code before implementation into the project.

## Purpose

Ensure all code generated by agents is:
1. **Correct** - Syntactically valid and logically sound
2. **Tested** - Verified with appropriate test coverage
3. **Clean** - No backward compatibility hacks or dead code
4. **Production-ready** - Follows project standards

---

## Verification Pipeline

```
┌─────────────────────────────────────────────────────────────────┐
│                    Agent Code Generation                         │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Stage 1: Static Analysis                                        │
│  - Syntax validation                                             │
│  - Dart analyzer                                                 │
│  - Lint checks                                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Stage 2: Code Quality Check                                     │
│  - No backward compatibility code                                │
│  - No dead code                                                  │
│  - No TODO/FIXME left unresolved                                │
│  - Follows project patterns                                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Stage 3: Unit Tests                                             │
│  - Generate tests if missing                                     │
│  - Run existing tests                                            │
│  - Verify coverage                                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Stage 4: Integration Tests                                      │
│  - Test with existing code                                       │
│  - Check for breaking changes                                    │
│  - Verify API contracts                                          │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  Stage 5: Build Verification                                     │
│  - Full project build                                            │
│  - Platform-specific builds                                      │
│  - No warnings allowed                                           │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  ✓ Approved for Implementation                                   │
└─────────────────────────────────────────────────────────────────┘
```

---

## Stage 1: Static Analysis

### Dart Analysis

```bash
#!/bin/bash
# scripts/verify-static-analysis.sh

set -e

echo "=== Stage 1: Static Analysis ==="

# Run dart analyzer
echo "Running Dart analyzer..."
dart analyze --fatal-infos --fatal-warnings

# Check formatting
echo "Checking code formatting..."
dart format --set-exit-if-changed .

# Run custom lints
echo "Running custom lints..."
dart run custom_lint

echo "✓ Stage 1 passed"
```

### analysis_options.yaml Requirements

```yaml
# analysis_options.yaml - Strict rules for agent-generated code

include: package:flutter_lints/flutter.yaml

analyzer:
  errors:
    # Treat all as errors for agent code
    dead_code: error
    unused_element: error
    unused_import: error
    unused_local_variable: error
    deprecated_member_use: error
    invalid_annotation_target: error
  exclude:
    - "**/*.g.dart"
    - "**/*.freezed.dart"
  language:
    strict-casts: true
    strict-inference: true
    strict-raw-types: true

linter:
  rules:
    # Mandatory for clean code
    - always_declare_return_types
    - avoid_dynamic_calls
    - avoid_print
    - avoid_type_to_string
    - avoid_unused_constructor_parameters
    - cancel_subscriptions
    - close_sinks
    - comment_references
    - dead_code
    - literal_only_boolean_expressions
    - no_adjacent_strings_in_list
    - no_duplicate_case_values
    - prefer_const_constructors
    - prefer_const_declarations
    - prefer_final_fields
    - prefer_final_locals
    - throw_in_finally
    - unnecessary_await_in_return
    - unnecessary_null_checks
    - unnecessary_statements
    - unused_element
```

---

## Stage 2: Code Quality Check

### Quality Rules

```dart
// scripts/quality_checker.dart

import 'dart:io';

class QualityChecker {
  final List<QualityRule> rules = [
    NoBackwardCompatibilityRule(),
    NoDeadCodeRule(),
    NoUnresolvedTodosRule(),
    NoDeprecatedUsageRule(),
    NoCommentedCodeRule(),
    NoMagicNumbersRule(),
    NoHardcodedStringsRule(),
  ];

  Future<QualityReport> check(List<File> files) async {
    final violations = <QualityViolation>[];

    for (final file in files) {
      final content = await file.readAsString();
      final lines = content.split('\n');

      for (final rule in rules) {
        violations.addAll(rule.check(file.path, lines));
      }
    }

    return QualityReport(
      totalFiles: files.length,
      violations: violations,
      passed: violations.where((v) => v.severity == Severity.error).isEmpty,
    );
  }
}

abstract class QualityRule {
  String get name;
  String get description;
  List<QualityViolation> check(String filePath, List<String> lines);
}

/// No backward compatibility code allowed
class NoBackwardCompatibilityRule extends QualityRule {
  @override
  String get name => 'no-backward-compat';

  @override
  String get description => 'No backward compatibility hacks allowed';

  final patterns = [
    RegExp(r'//\s*(?:TODO|FIXME):\s*remove\s+(?:after|when|in)', caseSensitive: false),
    RegExp(r'//\s*backward\s*compat', caseSensitive: false),
    RegExp(r'//\s*legacy', caseSensitive: false),
    RegExp(r'//\s*deprecated.*keep', caseSensitive: false),
    RegExp(r'@deprecated.*temporary', caseSensitive: false),
    RegExp(r'//\s*old\s+(?:code|implementation|version)', caseSensitive: false),
    RegExp(r'_?unused[A-Z]\w*\s*='), // Renamed unused variables
    RegExp(r'//\s*removed'), // Comments about removed code
    RegExp(r'export\s+.*//.*(?:backward|compat|legacy)', caseSensitive: false),
  ];

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];

    for (var i = 0; i < lines.length; i++) {
      final line = lines[i];
      for (final pattern in patterns) {
        if (pattern.hasMatch(line)) {
          violations.add(QualityViolation(
            rule: name,
            filePath: filePath,
            line: i + 1,
            message: 'Backward compatibility code detected: "${line.trim()}"',
            severity: Severity.error,
            suggestion: 'Remove backward compatibility code. Only clean production code is allowed.',
          ));
        }
      }
    }

    return violations;
  }
}

/// No dead/unreachable code
class NoDeadCodeRule extends QualityRule {
  @override
  String get name => 'no-dead-code';

  @override
  String get description => 'No dead or unreachable code';

  final patterns = [
    RegExp(r'return\s+\w+;\s*\n\s*[^}]'), // Code after return
    RegExp(r'throw\s+\w+;\s*\n\s*[^}]'), // Code after throw
    RegExp(r'if\s*\(\s*false\s*\)'), // if (false)
    RegExp(r'while\s*\(\s*false\s*\)'), // while (false)
    RegExp(r'&&\s*false'), // && false
    RegExp(r'\|\|\s*true'), // || true
  ];

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];
    final content = lines.join('\n');

    for (final pattern in patterns) {
      final matches = pattern.allMatches(content);
      for (final match in matches) {
        final lineNumber = content.substring(0, match.start).split('\n').length;
        violations.add(QualityViolation(
          rule: name,
          filePath: filePath,
          line: lineNumber,
          message: 'Dead code detected',
          severity: Severity.error,
          suggestion: 'Remove unreachable or dead code.',
        ));
      }
    }

    return violations;
  }
}

/// No unresolved TODOs or FIXMEs
class NoUnresolvedTodosRule extends QualityRule {
  @override
  String get name => 'no-unresolved-todos';

  @override
  String get description => 'No unresolved TODO/FIXME comments';

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];
    final pattern = RegExp(r'//\s*(TODO|FIXME|HACK|XXX|BUG):', caseSensitive: false);

    for (var i = 0; i < lines.length; i++) {
      final match = pattern.firstMatch(lines[i]);
      if (match != null) {
        violations.add(QualityViolation(
          rule: name,
          filePath: filePath,
          line: i + 1,
          message: '${match.group(1)} comment found: "${lines[i].trim()}"',
          severity: Severity.error,
          suggestion: 'Resolve the TODO/FIXME before committing, or remove if not applicable.',
        ));
      }
    }

    return violations;
  }
}

/// No deprecated API usage
class NoDeprecatedUsageRule extends QualityRule {
  @override
  String get name => 'no-deprecated';

  @override
  String get description => 'No usage of deprecated APIs';

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];

    for (var i = 0; i < lines.length; i++) {
      // Skip @Deprecated annotations (those are declarations)
      if (lines[i].contains('@Deprecated') || lines[i].contains('@deprecated')) {
        violations.add(QualityViolation(
          rule: name,
          filePath: filePath,
          line: i + 1,
          message: 'Deprecated declaration found',
          severity: Severity.error,
          suggestion: 'Do not create deprecated code. Write clean, current implementation.',
        ));
      }
    }

    return violations;
  }
}

/// No commented-out code
class NoCommentedCodeRule extends QualityRule {
  @override
  String get name => 'no-commented-code';

  @override
  String get description => 'No commented-out code blocks';

  final codePatterns = [
    RegExp(r'//\s*(if|for|while|switch|return|var|final|const|class|void|int|String|bool|double)\s'),
    RegExp(r'//\s*\w+\s*[=;{(]'),
    RegExp(r'//\s*\w+\.\w+\('),
  ];

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];
    var consecutiveCommentedLines = 0;
    var startLine = 0;

    for (var i = 0; i < lines.length; i++) {
      final line = lines[i].trim();

      // Check for commented code patterns
      final looksLikeCode = codePatterns.any((p) => p.hasMatch(line));

      if (line.startsWith('//') && looksLikeCode) {
        if (consecutiveCommentedLines == 0) {
          startLine = i + 1;
        }
        consecutiveCommentedLines++;
      } else {
        if (consecutiveCommentedLines >= 2) {
          violations.add(QualityViolation(
            rule: name,
            filePath: filePath,
            line: startLine,
            message: 'Commented-out code block ($consecutiveCommentedLines lines)',
            severity: Severity.warning,
            suggestion: 'Remove commented code. Use version control for history.',
          ));
        }
        consecutiveCommentedLines = 0;
      }
    }

    return violations;
  }
}

/// No magic numbers
class NoMagicNumbersRule extends QualityRule {
  @override
  String get name => 'no-magic-numbers';

  @override
  String get description => 'No magic numbers (except 0, 1, -1)';

  final allowed = {0, 1, -1, 2, 10, 100, 1000};

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];
    final pattern = RegExp(r'(?<![.\w])(\d{2,}|[3-9])(?![.\d\w])');

    for (var i = 0; i < lines.length; i++) {
      final line = lines[i];

      // Skip const declarations and obvious cases
      if (line.contains('const ') || line.contains('index') || line.contains('Duration')) {
        continue;
      }

      final matches = pattern.allMatches(line);
      for (final match in matches) {
        final number = int.tryParse(match.group(1) ?? '');
        if (number != null && !allowed.contains(number)) {
          violations.add(QualityViolation(
            rule: name,
            filePath: filePath,
            line: i + 1,
            message: 'Magic number $number found',
            severity: Severity.warning,
            suggestion: 'Extract magic number to a named constant.',
          ));
        }
      }
    }

    return violations;
  }
}

/// No hardcoded strings (except small ones)
class NoHardcodedStringsRule extends QualityRule {
  @override
  String get name => 'no-hardcoded-strings';

  @override
  String get description => 'No hardcoded user-facing strings';

  @override
  List<QualityViolation> check(String filePath, List<String> lines) {
    final violations = <QualityViolation>[];

    // Skip non-UI files
    if (!filePath.contains('/lib/') || filePath.contains('_test.dart')) {
      return violations;
    }

    final uiStringPattern = RegExp(r'''(?:Text|title|label|hint|message|error)\s*[:=]\s*['"]([^'"]{10,})['"]''');

    for (var i = 0; i < lines.length; i++) {
      final match = uiStringPattern.firstMatch(lines[i]);
      if (match != null) {
        violations.add(QualityViolation(
          rule: name,
          filePath: filePath,
          line: i + 1,
          message: 'Hardcoded string: "${match.group(1)}"',
          severity: Severity.warning,
          suggestion: 'Extract to localization file or constants.',
        ));
      }
    }

    return violations;
  }
}

enum Severity { error, warning, info }

class QualityViolation {
  final String rule;
  final String filePath;
  final int line;
  final String message;
  final Severity severity;
  final String suggestion;

  QualityViolation({
    required this.rule,
    required this.filePath,
    required this.line,
    required this.message,
    required this.severity,
    required this.suggestion,
  });

  @override
  String toString() {
    final icon = severity == Severity.error ? '✗' : severity == Severity.warning ? '⚠' : 'ℹ';
    return '$icon [$rule] $filePath:$line - $message\n  → $suggestion';
  }
}

class QualityReport {
  final int totalFiles;
  final List<QualityViolation> violations;
  final bool passed;

  QualityReport({
    required this.totalFiles,
    required this.violations,
    required this.passed,
  });

  void printReport() {
    print('\n=== Code Quality Report ===\n');
    print('Files checked: $totalFiles');
    print('Violations found: ${violations.length}');
    print('Errors: ${violations.where((v) => v.severity == Severity.error).length}');
    print('Warnings: ${violations.where((v) => v.severity == Severity.warning).length}');
    print('');

    if (violations.isNotEmpty) {
      print('Violations:\n');
      for (final violation in violations) {
        print(violation);
        print('');
      }
    }

    print(passed ? '✓ Quality check passed' : '✗ Quality check failed');
  }
}
```

### Run Quality Check

```bash
#!/bin/bash
# scripts/verify-quality.sh

set -e

echo "=== Stage 2: Code Quality Check ==="

# Run quality checker on changed files
dart run scripts/quality_checker.dart

echo "✓ Stage 2 passed"
```

---

## Stage 3: Unit Tests

### Test Generation

```dart
// scripts/test_generator.dart

import 'dart:io';

class TestGenerator {
  /// Generate tests for a Dart file if none exist
  Future<void> generateTestsIfMissing(String filePath) async {
    final testPath = _getTestPath(filePath);
    final testFile = File(testPath);

    if (await testFile.exists()) {
      print('Test file already exists: $testPath');
      return;
    }

    final sourceFile = File(filePath);
    final content = await sourceFile.readAsString();

    final testContent = _generateTests(filePath, content);
    await testFile.create(recursive: true);
    await testFile.writeAsString(testContent);

    print('Generated test file: $testPath');
  }

  String _getTestPath(String sourcePath) {
    return sourcePath
        .replaceFirst('/lib/', '/test/')
        .replaceFirst('.dart', '_test.dart');
  }

  String _generateTests(String sourcePath, String content) {
    final className = _extractClassName(content);
    final methods = _extractPublicMethods(content);
    final fileName = sourcePath.split('/').last.replaceFirst('.dart', '');

    final buffer = StringBuffer();
    buffer.writeln("import 'package:flutter_test/flutter_test.dart';");
    buffer.writeln("import '${_getRelativeImport(sourcePath)}';");
    buffer.writeln();
    buffer.writeln('void main() {');

    if (className != null) {
      buffer.writeln("  group('$className', () {");

      for (final method in methods) {
        buffer.writeln("    test('${method.name} should work correctly', () {");
        buffer.writeln('      // TODO: Implement test for ${method.name}');
        buffer.writeln("      expect(true, isTrue); // Placeholder");
        buffer.writeln('    });');
        buffer.writeln();
      }

      buffer.writeln('  });');
    }

    buffer.writeln('}');
    return buffer.toString();
  }

  String? _extractClassName(String content) {
    final match = RegExp(r'class\s+(\w+)').firstMatch(content);
    return match?.group(1);
  }

  List<MethodInfo> _extractPublicMethods(String content) {
    final methods = <MethodInfo>[];
    final pattern = RegExp(r'(?:Future<\w+>|\w+)\s+(\w+)\s*\([^)]*\)\s*(?:async\s*)?{');

    for (final match in pattern.allMatches(content)) {
      final name = match.group(1);
      if (name != null && !name.startsWith('_')) {
        methods.add(MethodInfo(name: name));
      }
    }

    return methods;
  }

  String _getRelativeImport(String sourcePath) {
    // Convert lib path to package import
    final packagePath = sourcePath.replaceFirst(RegExp(r'^.*/lib/'), 'package:myapp/');
    return packagePath;
  }
}

class MethodInfo {
  final String name;
  MethodInfo({required this.name});
}
```

### Run Unit Tests

```bash
#!/bin/bash
# scripts/verify-unit-tests.sh

set -e

echo "=== Stage 3: Unit Tests ==="

# Generate missing tests
dart run scripts/test_generator.dart

# Run tests with coverage
flutter test --coverage

# Check coverage threshold
dart run scripts/check_coverage.dart --threshold 80

echo "✓ Stage 3 passed"
```

---

## Stage 4: Integration Tests

### Integration Test Runner

```bash
#!/bin/bash
# scripts/verify-integration.sh

set -e

echo "=== Stage 4: Integration Tests ==="

# Run integration tests
flutter test integration_test/

# Check for breaking changes
dart run scripts/breaking_change_detector.dart

echo "✓ Stage 4 passed"
```

### Breaking Change Detector

```dart
// scripts/breaking_change_detector.dart

import 'dart:io';

class BreakingChangeDetector {
  /// Check if changes break existing API contracts
  Future<List<BreakingChange>> detect(List<String> changedFiles) async {
    final changes = <BreakingChange>[];

    for (final filePath in changedFiles) {
      // Get previous version from git
      final previousContent = await _getPreviousVersion(filePath);
      if (previousContent == null) continue;

      final currentContent = await File(filePath).readAsString();

      // Check for breaking changes
      changes.addAll(_checkRemovedPublicMembers(filePath, previousContent, currentContent));
      changes.addAll(_checkChangedSignatures(filePath, previousContent, currentContent));
      changes.addAll(_checkChangedReturnTypes(filePath, previousContent, currentContent));
    }

    return changes;
  }

  Future<String?> _getPreviousVersion(String filePath) async {
    try {
      final result = await Process.run('git', ['show', 'HEAD:$filePath']);
      if (result.exitCode == 0) {
        return result.stdout as String;
      }
    } catch (_) {}
    return null;
  }

  List<BreakingChange> _checkRemovedPublicMembers(
    String filePath,
    String previous,
    String current,
  ) {
    final changes = <BreakingChange>[];

    final previousPublic = _extractPublicMembers(previous);
    final currentPublic = _extractPublicMembers(current);

    for (final member in previousPublic) {
      if (!currentPublic.contains(member)) {
        changes.add(BreakingChange(
          file: filePath,
          type: BreakingChangeType.removedMember,
          description: 'Public member removed: $member',
        ));
      }
    }

    return changes;
  }

  List<BreakingChange> _checkChangedSignatures(
    String filePath,
    String previous,
    String current,
  ) {
    // Implementation for signature change detection
    return [];
  }

  List<BreakingChange> _checkChangedReturnTypes(
    String filePath,
    String previous,
    String current,
  ) {
    // Implementation for return type change detection
    return [];
  }

  Set<String> _extractPublicMembers(String content) {
    final members = <String>{};
    final pattern = RegExp(r'(?:class|void|Future|String|int|bool|double|List|Map)\s+(\w+)');

    for (final match in pattern.allMatches(content)) {
      final name = match.group(1);
      if (name != null && !name.startsWith('_')) {
        members.add(name);
      }
    }

    return members;
  }
}

enum BreakingChangeType {
  removedMember,
  changedSignature,
  changedReturnType,
  removedExport,
}

class BreakingChange {
  final String file;
  final BreakingChangeType type;
  final String description;

  BreakingChange({
    required this.file,
    required this.type,
    required this.description,
  });
}
```

---

## Stage 5: Build Verification

### Full Build Check

```bash
#!/bin/bash
# scripts/verify-build.sh

set -e

echo "=== Stage 5: Build Verification ==="

# Clean previous builds
flutter clean

# Get dependencies
flutter pub get

# Build all platforms
echo "Building Android..."
flutter build apk --release --no-tree-shake-icons 2>&1 | tee build_android.log
if grep -q "warning" build_android.log; then
  echo "✗ Android build has warnings"
  exit 1
fi

echo "Building iOS..."
flutter build ios --release --no-codesign 2>&1 | tee build_ios.log
if grep -q "warning" build_ios.log; then
  echo "✗ iOS build has warnings"
  exit 1
fi

echo "Building Web..."
flutter build web --release 2>&1 | tee build_web.log
if grep -q "warning" build_web.log; then
  echo "✗ Web build has warnings"
  exit 1
fi

# Cleanup logs
rm -f build_*.log

echo "✓ Stage 5 passed"
```

---

## Complete Verification Script

```bash
#!/bin/bash
# scripts/verify-all.sh

set -e

echo "╔═══════════════════════════════════════════════════════════╗"
echo "║         Agent Code Verification Pipeline                   ║"
echo "╚═══════════════════════════════════════════════════════════╝"
echo ""

# Track timing
START_TIME=$(date +%s)

# Stage 1
./scripts/verify-static-analysis.sh || { echo "✗ Failed at Stage 1"; exit 1; }

# Stage 2
./scripts/verify-quality.sh || { echo "✗ Failed at Stage 2"; exit 1; }

# Stage 3
./scripts/verify-unit-tests.sh || { echo "✗ Failed at Stage 3"; exit 1; }

# Stage 4
./scripts/verify-integration.sh || { echo "✗ Failed at Stage 4"; exit 1; }

# Stage 5
./scripts/verify-build.sh || { echo "✗ Failed at Stage 5"; exit 1; }

END_TIME=$(date +%s)
DURATION=$((END_TIME - START_TIME))

echo ""
echo "╔═══════════════════════════════════════════════════════════╗"
echo "║  ✓ All verification stages passed                          ║"
echo "║  Duration: ${DURATION}s                                              ║"
echo "║  Code is approved for implementation                       ║"
echo "╚═══════════════════════════════════════════════════════════╝"
```

---

## Pre-Implementation Checklist

Before any agent-generated code goes into production:

```markdown
## Pre-Implementation Checklist

### Code Quality
- [ ] No syntax errors (dart analyze passes)
- [ ] No lint warnings
- [ ] Code formatted (dart format)
- [ ] No backward compatibility hacks
- [ ] No dead code
- [ ] No unresolved TODOs
- [ ] No deprecated API usage
- [ ] No commented-out code
- [ ] No magic numbers
- [ ] No hardcoded strings (for UI)

### Testing
- [ ] Unit tests exist and pass
- [ ] Integration tests pass
- [ ] Code coverage >= 80%
- [ ] No flaky tests

### Build
- [ ] Android build succeeds (no warnings)
- [ ] iOS build succeeds (no warnings)
- [ ] Web build succeeds (no warnings)
- [ ] All platform tests pass

### Documentation
- [ ] Public APIs documented
- [ ] Complex logic explained
- [ ] README updated if needed

### Review
- [ ] Code follows project patterns
- [ ] No security vulnerabilities
- [ ] No performance issues
- [ ] Changes are minimal and focused
```

---

## Integration with Agents

### Usage in Other Agents

```markdown
## Post-Code-Generation Protocol

After generating code, every agent must:

1. Run verification pipeline:
   ```bash
   ./scripts/verify-all.sh
   ```

2. If verification fails:
   - Analyze the failure
   - Fix the issues
   - Re-run verification
   - Record learnings in memory

3. If verification passes:
   - Proceed with implementation
   - Record successful patterns

4. Never commit code that fails verification
```

### Automatic Triggers

```yaml
# When to run verification
triggers:
  - on_code_generation: always
  - on_code_modification: always
  - before_commit: required
  - before_merge: required
```

---

## Trigger Keywords

- "verify code"
- "test agent code"
- "check quality"
- "run verification"
- "validate implementation"

---

## Checklist

- [ ] Static analysis configured
- [ ] Quality checker implemented
- [ ] Test generator ready
- [ ] Integration tests set up
- [ ] Build verification scripts created
- [ ] All stages passing
- [ ] Documentation complete
